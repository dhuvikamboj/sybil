/**
 * Dynamic Skill Generator
 * 
 * Allows the agent to create new skills based on user needs and learned behaviors.
 * Skills are saved as SKILL.md files following the Agent Skills specification.
 */

import { createTool } from "@mastra/core/tools";
import { z } from "zod";
import { promises as fs } from "fs";
import { join } from "path";
import { fileURLToPath } from "url";

const __dirname = fileURLToPath(new URL(".", import.meta.url));
const SKILLS_DIR = join(__dirname, "..", "..", "..", "..", "skills");

/**
 * SKILL.md template following Agent Skills specification
 */
const SKILL_TEMPLATE = `---
name: {{name}}
description: {{description}}
version: {{version}}
tags:
{{tags}}
---

# {{title}}

{{instructions}}

## When to Use This Skill

{{usageContext}}

## Guidelines

{{guidelines}}

## Examples

{{examples}}

## Related Skills

{{relatedSkills}}

---
*Generated by sybil at {{timestamp}}*
`;

/**
 * Helper function to create a skill file
 */
async function createSkillFile(
  name: string,
  description: string,
  instructions: string,
  usageContext: string,
  guidelines: string[],
  tags: string[],
  examples: Array<{ scenario: string; approach: string }> = [],
  relatedSkills: string[] = []
): Promise<{ success: boolean; filePath: string; message: string }> {
  try {
    // Validate skill name
    if (!/^[a-z0-9-]+$/.test(name)) {
      return {
        success: false,
        filePath: "",
        message: "Skill name must be lowercase alphanumeric with hyphens only",
      };
    }

    // Format content
    const formattedTags = tags.map(tag => `  - ${tag}`).join("\n");
    const formattedGuidelines = guidelines.map(g => `- ${g}`).join("\n");

    // Format examples
    const formattedExamples = examples.length > 0
      ? examples.map((ex, i) => `### Example ${i + 1}\n**Scenario:** ${ex.scenario}\n\n**Approach:**\n${ex.approach}`).join("\n\n")
      : "No examples provided yet.";

    // Format related skills
    const formattedRelated = relatedSkills.length > 0
      ? relatedSkills.map(s => `- ${s}`).join("\n")
      : "- None";

    // Create skill content
    const skillContent = SKILL_TEMPLATE
      .replace(/{{name}}/g, name)
      .replace(/{{description}}/g, description)
      .replace(/{{version}}/g, "1.0.0")
      .replace(/{{tags}}/g, formattedTags)
      .replace(/{{title}}/g, name.split("-").map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" "))
      .replace(/{{instructions}}/g, instructions)
      .replace(/{{usageContext}}/g, usageContext)
      .replace(/{{guidelines}}/g, formattedGuidelines)
      .replace(/{{examples}}/g, formattedExamples)
      .replace(/{{relatedSkills}}/g, formattedRelated)
      .replace(/{{timestamp}}/g, new Date().toISOString());

    // Create skill directory
    const skillDir = join(SKILLS_DIR, name);
    await fs.mkdir(skillDir, { recursive: true });

    // Save SKILL.md
    const filePath = join(skillDir, "SKILL.md");
    await fs.writeFile(filePath, skillContent, "utf-8");

    // Create empty references directory
    const refsDir = join(skillDir, "references");
    await fs.mkdir(refsDir, { recursive: true });

    return {
      success: true,
      filePath,
      message: `Skill "${name}" created successfully!`,
    };
  } catch (error) {
    return {
      success: false,
      filePath: "",
      message: `Failed to create skill: ${error instanceof Error ? error.message : "Unknown error"}`,
    };
  }
}

/**
 * Tool to generate a new skill
 */
export const generateSkillTool = createTool({
  id: "generate-skill",
  description: `
    Create a new skill that the agent can use to handle specific types of tasks.
    Skills teach the agent how to approach particular domains or tasks effectively.
    
    Examples:
    - "Create a skill for writing professional emails"
    - "Generate a skill for analyzing data"
    - "Make a skill for debugging code"
    - "Create a skill for customer support conversations"
  `,
  inputSchema: z.object({
    name: z.string().describe("Unique identifier for the skill (e.g., 'professional-email-writing')"),
    description: z.string().describe("Brief description of what this skill teaches"),
    category: z.enum([
      "communication",
      "technical",
      "creative",
      "analytical",
      "planning",
      "research",
      "social",
      "custom"
    ]).describe("Skill category"),
    instructions: z.string().describe("Detailed instructions on how to apply this skill"),
    usageContext: z.string().describe("When and why to use this skill"),
    guidelines: z.array(z.string()).describe("Specific guidelines and best practices"),
    examples: z.array(z.object({
      scenario: z.string().describe("Example scenario"),
      approach: z.string().describe("How to handle it"),
    })).optional().describe("Example applications"),
    relatedSkills: z.array(z.string()).optional().describe("Related skills to reference"),
    tags: z.array(z.string()).describe("Tags for categorization"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    skillId: z.string(),
    filePath: z.string(),
    message: z.string(),
    skillContent: z.string(),
  }),
  execute: async (inputData) => {
    const {
      name,
      description,
      instructions,
      usageContext,
      guidelines,
      examples = [],
      relatedSkills = [],
      tags,
    } = inputData;

    const result = await createSkillFile(
      name,
      description,
      instructions,
      usageContext,
      guidelines,
      tags,
      examples,
      relatedSkills
    );

    // Read back the content if successful
    let skillContent = "";
    if (result.success && result.filePath) {
      try {
        skillContent = await fs.readFile(result.filePath, "utf-8");
      } catch {
        skillContent = "Skill created but content could not be read back";
      }
    }

    return {
      success: result.success,
      skillId: name,
      filePath: result.filePath,
      message: result.message,
      skillContent,
    };
  },
});

/**
 * Tool to learn a skill from user feedback
 */
export const learnSkillFromFeedbackTool = createTool({
  id: "learn-skill-from-feedback",
  description: `
    Learn a new skill or improve an existing one based on user feedback.
    This tool analyzes what the user liked/disliked and extracts patterns
    to create or update a skill.
  `,
  inputSchema: z.object({
    skillName: z.string().describe("Name of the skill to create or update"),
    feedback: z.string().describe("User feedback about what was good/bad"),
    taskDescription: z.string().describe("Description of the task that was performed"),
    successPatterns: z.array(z.string()).describe("What worked well"),
    improvementAreas: z.array(z.string()).describe("What could be improved"),
    isUpdate: z.boolean().optional().describe("Whether to update existing skill"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    skillId: z.string(),
    message: z.string(),
    changes: z.array(z.string()).describe("What was learned/added"),
  }),
  execute: async (inputData) => {
    const {
      skillName,
      feedback,
      taskDescription,
      successPatterns,
      improvementAreas,
      isUpdate = false,
    } = inputData;

    try {
      const skillDir = join(SKILLS_DIR, skillName);
      const skillFile = join(skillDir, "SKILL.md");

      let changes: string[] = [];

      if (isUpdate) {
        // Update existing skill
        try {
          let skillContent = await fs.readFile(skillFile, "utf-8");

          // Add learned patterns
          const learnedSection = `\n\n## Learned Patterns (Updated ${new Date().toISOString()})\n\n### Success Patterns\n${successPatterns.map(p => `- ${p}`).join("\n")}\n\n### Areas for Improvement\n${improvementAreas.map(a => `- ${a}`).join("\n")}\n\n### User Feedback\n> ${feedback}`;

          // Append to skill content
          skillContent = skillContent + learnedSection;
          await fs.writeFile(skillFile, skillContent, "utf-8");

          changes.push("Added new learned patterns based on feedback");
        } catch {
          return {
            success: false,
            skillId: skillName,
            message: `Skill "${skillName}" not found for update`,
            changes: [],
          };
        }
      } else {
        // Create new skill from feedback
        const instructions = `When handling ${taskDescription}:

1. Apply these success patterns:
${successPatterns.map(p => `   - ${p}`).join("\n")}

2. Avoid these common issues:
${improvementAreas.map(a => `   - ${a}`).join("\n")}`;

        const skillResult = await createSkillFile(
          skillName,
          `Skill learned from user feedback for handling ${taskDescription}`,
          instructions,
          `Use this skill when dealing with similar situations to the one that generated this feedback: ${taskDescription}`,
          [...successPatterns, ...improvementAreas.map(a => `Avoid: ${a}`)],
          ["learned", "feedback-based"]
        );

        if (skillResult.success) {
          changes.push("Created new skill based on feedback");
        }

        return {
          success: skillResult.success,
          skillId: skillName,
          message: skillResult.message,
          changes,
        };
      }

      return {
        success: true,
        skillId: skillName,
        message: `Skill "${skillName}" ${isUpdate ? "updated" : "created"} from feedback`,
        changes,
      };
    } catch (error) {
      return {
        success: false,
        skillId: skillName,
        message: `Failed to learn skill: ${error instanceof Error ? error.message : "Unknown error"}`,
        changes: [],
      };
    }
  },
});

/**
 * Tool to list all available skills
 */
export const listSkillsTool = createTool({
  id: "list-skills",
  description: "List all available skills that can be activated",
  inputSchema: z.object({
    category: z.enum([
      "all",
      "communication",
      "technical",
      "creative",
      "analytical",
      "planning",
      "research",
      "social",
      "custom"
    ]).optional(),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    skills: z.array(z.object({
      name: z.string(),
      description: z.string(),
      category: z.string(),
      tags: z.array(z.string()),
      version: z.string(),
    })),
    count: z.number(),
  }),
  execute: async (inputData) => {
    try {
      await fs.mkdir(SKILLS_DIR, { recursive: true });
      const entries = await fs.readdir(SKILLS_DIR, { withFileTypes: true });

      const skills = [];

      for (const entry of entries) {
        if (entry.isDirectory()) {
          const skillFile = join(SKILLS_DIR, entry.name, "SKILL.md");
          try {
            const content = await fs.readFile(skillFile, "utf-8");

            // Parse frontmatter
            const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
            if (frontmatterMatch) {
              const frontmatter = frontmatterMatch[1];
              const name = frontmatter.match(/name:\s*(.+)/)?.[1] || entry.name;
              const description = frontmatter.match(/description:\s*(.+)/)?.[1] || "";
              const version = frontmatter.match(/version:\s*(.+)/)?.[1] || "1.0.0";
              const tags = frontmatter.match(/tags:\s*\n([\s\S]*?)(?=\n\w|$)/)?.[1]
                ?.split("\n")
                .filter(t => t.trim().startsWith("-"))
                .map(t => t.replace(/-\s*/, "").trim()) || [];

              // Determine category from tags
              const category = tags.find(t => [
                "communication",
                "technical",
                "creative",
                "analytical",
                "planning",
                "research",
                "social"
              ].includes(t)) || "custom";

              skills.push({
                name,
                description,
                category,
                tags,
                version,
              });
            }
          } catch {
            // Skip if can't read skill file
          }
        }
      }

      return {
        success: true,
        skills,
        count: skills.length,
      };
    } catch (error) {
      return {
        success: false,
        skills: [],
        count: 0,
      };
    }
  },
});

/**
 * Tool to activate a skill
 */
export const activateSkillTool = createTool({
  id: "activate-skill",
  description: "Activate a skill for use in the current conversation",
  inputSchema: z.object({
    skillName: z.string().describe("Name of the skill to activate"),
    context: z.string().optional().describe("Additional context for skill usage"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    skillName: z.string(),
    instructions: z.string(),
    message: z.string(),
  }),
  execute: async (inputData) => {
    const { skillName, context } = inputData;

    try {
      const skillFile = join(SKILLS_DIR, skillName, "SKILL.md");
      const content = await fs.readFile(skillFile, "utf-8");

      // Extract main content (after frontmatter)
      const mainContent = content.replace(/^---\n[\s\S]*?\n---\n/, "");

      return {
        success: true,
        skillName,
        instructions: mainContent,
        message: `Skill "${skillName}" activated${context ? ` for: ${context}` : ""}. Following skill guidelines now.`,
      };
    } catch (error) {
      return {
        success: false,
        skillName,
        instructions: "",
        message: `Failed to activate skill "${skillName}": ${error instanceof Error ? error.message : "Not found"}`,
      };
    }
  },
});

/**
 * Tool to analyze performance and suggest new skills
 */
export const analyzeForSkillOpportunityTool = createTool({
  id: "analyze-for-skill-opportunity",
  description: `
    Analyze recent interactions to identify opportunities for new skills.
    This tool looks for patterns where the agent struggled or where a skill
    would have been helpful.
  `,
  inputSchema: z.object({
    interactionHistory: z.array(z.object({
      userMessage: z.string(),
      botResponse: z.string(),
      success: z.boolean(),
      feedback: z.string().optional(),
    })).describe("Recent interactions to analyze"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    opportunities: z.array(z.object({
      type: z.string(),
      description: z.string(),
      suggestedSkillName: z.string(),
      priority: z.enum(["high", "medium", "low"]),
    })),
    summary: z.string(),
  }),
  execute: async (inputData) => {
    const { interactionHistory } = inputData;

    try {
      const opportunities = [];

      // Analyze for patterns
      const failedInteractions = interactionHistory.filter(i => !i.success);
      const domainPatterns = new Map<string, number>();

      // Count domain-specific keywords
      for (const interaction of interactionHistory) {
        const text = interaction.userMessage.toLowerCase();

        const domains = [
          { name: "data-analysis", keywords: ["data", "analyze", "chart", "graph", "statistics"] },
          { name: "code-review", keywords: ["code", "review", "debug", "fix", "error"] },
          { name: "writing", keywords: ["write", "draft", "email", "document", "content"] },
          { name: "research", keywords: ["research", "find", "search", "investigate", "learn"] },
          { name: "planning", keywords: ["plan", "schedule", "organize", "timeline", "project"] },
        ];

        for (const domain of domains) {
          if (domain.keywords.some(k => text.includes(k))) {
            domainPatterns.set(domain.name, (domainPatterns.get(domain.name) || 0) + 1);
          }
        }
      }

      // Identify high-frequency domains without dedicated skills
      for (const [domain, count] of domainPatterns) {
        if (count >= 3) {
          opportunities.push({
            type: "domain-specific",
            description: `Frequent requests related to ${domain.replace("-", " ")}`,
            suggestedSkillName: domain,
            priority: count >= 5 ? "high" : "medium",
          });
        }
      }

      // Check for failed interactions
      if (failedInteractions.length >= 3) {
        opportunities.push({
          type: "capability-gap",
          description: `Multiple failed interactions suggest a need for better handling strategies`,
          suggestedSkillName: "improved-error-handling",
          priority: "high",
        });
      }

      const summary = opportunities.length > 0
        ? `Found ${opportunities.length} opportunities for new skills. Consider creating skills for: ${opportunities.map(o => o.suggestedSkillName).join(", ")}`
        : "No clear skill opportunities identified from recent interactions";

      return {
        success: true,
        opportunities,
        summary,
      };
    } catch (error) {
      return {
        success: false,
        opportunities: [],
        summary: `Analysis failed: ${error instanceof Error ? error.message : "Unknown error"}`,
      };
    }
  },
});

export default {
  generateSkill: generateSkillTool,
  learnSkillFromFeedback: learnSkillFromFeedbackTool,
  listSkills: listSkillsTool,
  activateSkill: activateSkillTool,
  analyzeForSkillOpportunity: analyzeForSkillOpportunityTool,
};
